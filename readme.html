<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>File I/O tracing on Windows &amp; Linux</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="readme_files/libs/clipboard/clipboard.min.js"></script>
<script src="readme_files/libs/quarto-html/quarto.js"></script>
<script src="readme_files/libs/quarto-html/popper.min.js"></script>
<script src="readme_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="readme_files/libs/quarto-html/anchor.min.js"></script>
<link href="readme_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="readme_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="readme_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="readme_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="readme_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">File I/O tracing on Windows &amp; Linux</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="task" class="level4">
<h4 class="anchored" data-anchor-id="task">Task</h4>
<p>Bir agent yazın. Bu agent Windows ve Linux ortamlarda çalışmaya uygun olmalı. Agent çalıştırıldığında listen modda host’un dosya trafiğini monitor etmeye başlasın. Sisteme yeni bir dosya yazıldığında ya da mevcut dosya modifiye edildiğinde belirleyeceğiniz indikatörleri(hash, değişen byte verisi vs.) Elastic search’e kaydedin. Kibana’da kayıtlı veriler için bir dashboard tasarlayın.</p>
</section>
<section id="approaches" class="level3">
<h3 class="anchored" data-anchor-id="approaches">Approaches</h3>
<section id="windows" class="level4">
<h4 class="anchored" data-anchor-id="windows">Windows</h4>
<ul>
<li><p><strong><em>Event Tracing for Windows (ETW)</em></strong></p>
<p>Windows and other applications implement their <strong><em>Providers</em></strong> to enable log/tracing of events. Provider events are then enabled/registered/subscribed via <strong><em>Controller</em></strong> sessions. <strong><em>Consumers</em></strong> select/subscribe to tracing sessions to receive real-time(or from a file) event feed.</p>
<p>logman cli tool can be used to view active tracing sessions, provider capabilities etc.</p>
<p>Providers around File/Disk I/O</p>
<ul>
<li><p>Microsoft-Windows-Kernel-File</p></li>
<li><p>Microsoft-Windows-Kernel-Disk</p></li>
<li><p>Microsoft-Windows-Disk</p></li>
<li><p>Microsoft-Windows-FileInfoMinifilter</p></li>
</ul>
<p>KrabsETW is a modern C++ wrapper around the low-level ETW trace consumption functions, by Microsoft.</p>
<p>!Missing Events</p>
<p>!Common Bypasses</p>
<p>Cons:</p>
<ul>
<li><p>Can’t trace bytes written/changes? Snapshot and diff changes?</p></li>
<li><p>It’s known to be used by EDR’s and there are some easy evading techniques that should be checked</p></li>
</ul>
<p>sources:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing">MS / About Event Tracing</a></li>
<li><a href="https://github.com/microsoft/krabsetw">microsoft/krabsETW provides a modern C++ wrapper around the low-level ETW trace consumption functions.</a></li>
<li><a href="https://devblogs.microsoft.com/pix/file-io-captures/">File IO Captures on Windows PIX are ETW based</a></li>
<li><a href="https://devblogs.microsoft.com/oldnewthing/20201125-00/?p=104480">Preliminary notes on analyzing Disk and File I/O performance with ETW traces - The Old New Thing</a></li>
<li><a href="https://devblogs.microsoft.com/oldnewthing/20201126-00/?p=104488">Disk and File I/O performance with ETW traces: Why is System doing so much stuff? - The Old New Thing</a></li>
<li><a href="https://devblogs.microsoft.com/oldnewthing/20201127-00/?p=104492">Disk and File I/O performance with ETW traces: Miscellany - The Old New Thing</a></li>
<li><a href="https://github.com/thefLink/Hunt-Weird-Syscalls">thefLink/Hunt-Weird-Syscalls - Using kernel based ETW providers to identify&amp;validate syscall sources by following the event calltrace - catching unauthorized direct and indirect syscalls</a></li>
<li><a href="https://www.youtube.com/watch?v=AucQUjJBJuw">Morph Your Malware! Talk by Sebastian Feldmann(thefLink). Mentions various syscall tracking methods and bypasses</a></li>
<li><a href="https://randomascii.wordpress.com/2015/09/24/etw-central/">ETW Central</a></li>
</ul></li>
</ul>
<!-- -->
<ul>
<li><p><strong><em>Windows API Hooking</em></strong></p>
<p>Normal user space programs use Windows API calls to do os/kernel stuff. These API’s can be hooked with various methods to trace/control/</p>
<p>Cons:</p>
<ul>
<li>It’s a well known and well studied method. With methods to Evade it.</li>
</ul>
<p>Evasion:</p>
<ul>
<li><p>Checking if the API’s are hooked:</p>
<p>by comparing in memory methods to dll file methods</p>
<p>by checking target methods first insturctions for jmps</p></li>
<li><p>doing direct syscalls instead of using API’s</p></li>
<li><p>indirect syscalls</p></li>
<li><p>Unhooking</p></li>
</ul>
<p>Methods:</p>
<ul>
<li><p>Import Adress Table (IAT)</p></li>
<li><p>Export Adress Table (EAT)</p></li>
<li><p>Inline Hooking</p></li>
<li><p>Interrup Descriptor Table (IDT) (?)</p></li>
<li><p>MSR?</p></li>
<li><p>Nirvana?</p>
<p><a href="https://winternl.com/detecting-manual-syscalls-from-user-mode/">Detecting Manual Syscalls from User Mode via Nirvana</a></p></li>
<li><p>Frida?</p></li>
</ul>
<p>sources:</p>
<ul>
<li><a href="https://github.com/microsoft/Detours/wiki">microsoft/Detours</a></li>
<li><a href="https://github.com/EasyHook/EasyHook">EasyHook</a></li>
<li><a href="https://github.com/stevemk14ebr/polyhook_2_0">PolyHook 2.0 C++ 20, x86/x64 Hooking Libary v2.0</a></li>
<li><a href="https://www.apriorit.com/dev-blog/win-comparison-of-api-hooking-libraries">Practical Comparison of the Most Popular API Hooking Libraries: Microsoft Detours, EasyHook, Nektra Deviare, and Mhook</a></li>
<li><a href="https://rogerorr.github.io/NtTrace/SimilarTools.html">Similiar Tools to NtTrace (strace like for Windows) and comparison</a></li>
<li><a href="https://github.com/apriorit/APIHookingLibraries" class="uri">https://github.com/apriorit/APIHookingLibraries</a></li>
<li><a href="https://www.apriorit.com/dev-blog/469-mhook-enhancements">apriorit/Mhook Enhancements: 10x Speed Improvement and Other Fixes</a></li>
<li><a href="https://github.com/vic4key/py-hooking">Cross Platform Hooking from Python</a> (?)</li>
<li><a href="http://jbremer.org/x86-api-hooking-demystified/">jbremer.org/x86-api-hooking-demystified</a></li>
<li><a href="https://stackoverflow.com/a/19448275">? ASLR + Sytem Wide Hooks</a></li>
<li><a href="https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/">Syscall Journey in the Windows Kernel - Alice Climent-Pommeret</a></li>
</ul></li>
<li><p><strong><em>File System Filter Driver</em></strong></p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/about-file-system-filter-drivers" class="uri">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/about-file-system-filter-drivers</a></p></li>
<li><p><strong><em>ReadDirectoryChangesW / IOCPs</em></strong></p>
<p>mehhh Most cross-platform file/directory watcher libraries use this method on Windows but I’m not sure if they’re meant for security</p>
<p>sources:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications">obtaining-directory-change-notifications</a></li>
<li><a href="https://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html">Understanding ReadDirectoryChangesW</a></li>
<li><a href="https://medium.com/tresorit-engineering/how-to-get-notifications-about-file-system-changes-on-windows-519dd8c4fb01">using I/O completion ports(IOCPs) to get file system change notifications on windows</a></li>
<li><a href="https://gist.github.com/nickav/a57009d4fcc3b527ed0f5c9cf30618f8">how to poll ReadDirectoryChangesW on Windows</a></li>
<li><a href="https://github.com/SpartanJ/efsw/tree/master">efsw is a C++ cross-platform file system watcher and notifier.</a></li>
<li><a href="https://github.com/notify-rs/notify">notify-rs</a></li>
<li><a href="https://github.com/fsnotify/fsnotify?tab=readme-ov-file">fsnotify</a></li>
</ul></li>
<li><p><strong><em>Change Journal Records</em></strong></p>
<p>sources:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/change-journals">windows/win32/fileio/change-journals</a></li>
</ul></li>
<li><p><strong><em>Periodically + on Change Hash&amp;Snapshot Filesystem diff changes</em></strong></p></li>
<li><p><strong><em>eBPF for windows?</em></strong></p></li>
<li><p><strong><em>DTrace</em></strong></p>
<p>? pipe to custom app to consume ? does it really provide more stuff + protection than etw ?</p>
<p>sources:</p>
<ul>
<li><a href="https://techcommunity.microsoft.com/t5/windows-os-platform-blog/dtrace-on-windows/ba-p/362902">dtrace-on-windows</a></li>
</ul></li>
<li><p><strong><em>Virtual Machine Introspection(VMI) / HyperDbg</em></strong></p>
<p>source:</p>
<ul>
<li><a href="https://docs.hyperdbg.org/">HyperDbg - A hypervisor-assisted debugger designed for analyzing, fuzzing and reversing</a></li>
</ul></li>
</ul>
<p>If not using VMI or File System Filter Drivers like deep methods, the optimal way to cover the most seems to me that:</p>
<p>DTrace</p>
<p>or</p>
<p>ETW for File I/O + Weird Syscalls(like Hunt-Weird-Syscalls) with ETW Evasion checks</p>
<p>+</p>
<p>user space API Hooking to trace changes (optional if the targets behaviour changes on hook detection)</p>
<p>or</p>
<p>Snapshotting and diffing files to trace changes</p>
</section>
<section id="linux" class="level4">
<h4 class="anchored" data-anchor-id="linux">Linux</h4>
<ul>
<li><p><strong><em>eBPF</em></strong></p>
<p>Looks like Procmon for Linux use this method.</p>
<p>sources:</p>
<ul>
<li><a href="https://github.com/Sysinternals/ProcMon-for-Linux/tree/main/src/tracer">Sysinternals/ProcMon-for-Linux</a></li>
</ul></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>